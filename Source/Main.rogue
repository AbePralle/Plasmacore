uses Plasmacore

Display( "Main" ).screen = MainScreen

class Plot : Sprite
  METHODS
    method init_object
      draggable

    method on( e:PointerEvent )

    method on_drag
endClass

class MainScreen : Screen [singleton]
  PROPERTIES
    scene = Scene()
    holder : Entity

  METHODS
    method on_start
      scene.add( Layer("under") )

      local bg = Background( "background_reference.png", XY(0.60,0.60) ).[ attach(scene), name="bg" ]

      scene.add( Layer("shadow") subclass
        METHODS
          method draw( image:Image )
            local old_colors = image.colors
            #local old_shader = image.shader
            image.color = Color.BLACK
            #image.shader = ImageShader.TEXTURE_WITH_COLOR_FILL
            image.draw( image.position + XY(4,4) )
            #image.shader = old_shader
            image.colors = old_colors
      endSubclass )

      scene.add( Layer("over") )
      scene.default_layer = "over"

      local start_x = 614
      local start_y = 759
      forEach (j in 0..2)
        local x = start_x
        local y = start_y
        forEach (i in 0..2)
          bg.add( Plot("plot_blocked.png").[name="plot",position=XY(x,y),layer+="shadow"] )
          x -= 134
          y -= 72
        endForEach
        start_x += 134
        start_y -= 72
      endForEach

      holder = Entity( bg.child_bounds.value ).[ name="holder" ]
      bg.add( holder, &translate )
      scene.child.child.layer = "under"
      loop (9) holder.add( scene.child.child, &translate )

      local carrot = Sprite("carrot.png").[draggable,position=bg.size/2,layer += "shadow",name="carrot"]
#trace scene.layer("under").mask->String(&binary,4)
#trace scene.layer("shadow").mask->String(&binary,4)
#trace scene.layer("over").mask->String(&binary,4)
      bg.add( carrot )

      change_state( IdleState() )

    method on( e:KeyEvent )
      if (e.is_press(Keycode.LEFT_ARROW))  shift_plots( XY(-1,0) )
      if (e.is_press(Keycode.RIGHT_ARROW)) shift_plots( XY(1,0) )
      if (e.is_press(Keycode.UP_ARROW))    shift_plots( XY(0,-1) )
      if (e.is_press(Keycode.DOWN_ARROW))  shift_plots( XY(0,1) )
      if (e.is_press(Keycode.V))
        local setting = not scene.child.child.is_enabled
        scene.child.apply_to_children( (entity) with (setting) => entity.enabled = setting )
      endIf

    method shift_plots( delta:XY )
      scene.child.apply_to_children( (entity) with (delta) => entity.position += delta )

    method on_draw
      Display.clear( Color.BLUE )
      scene.draw
      #scene.apply( (entity)=>entity.bounding_quad.draw(Color.RED) )
      #scene.apply( (entity)=>entity.bounding_box.draw(Color.RED) )
      #scene.child.child.bounding_box.draw( Color.RED )
      #holder.bounding_box.draw( Color.RED )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

class MainState : State<<MainScreen>>;

class IdleState : MainState
  METHODS
    method on( e:PointerEvent )
      screen.scene.handle( e )
      #{
      if (e.is_press)
        local entity = screen.scene.find( e.position, &selectable )
        if (entity) change_state( DragState(entity,e.position) )
      endIf
      }#
endClass

class DragState : MainState
  PROPERTIES
    entity : Entity
    offset : XY

  METHODS
    method init( entity, position:XY )
      offset = entity.position - entity.to_parent_local(position)

    method on( e:PointerEvent )
      if (e.is_move)
        entity.position = entity.to_parent_local(e.position) + offset
      elseIf (e.is_release)
        change_state( IdleState() )
      endIf
endClass

#{
class MainScreen : Screen [singleton]
  PROPERTIES

  METHODS
    method on_start
      change_state( InitialState() )

    method on( e:PointerEvent )

    method on_draw

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass


class InitialState : State<<MainScreen>>
  METHODS
    method on_start
      # Called when this state becomes the active state
      println "Hello World"

    method after_draw
      # This happens after the current screen's on_draw()

    method on( e:KeyEvent )
      trace e

    method on( e:PointerEvent )
      if (e.is_press or e.is_release) trace e

    method on( e:TextEvent )
      trace e

    method on_draw
      # This happens before the current screen's on_draw()
      Display.clear( Color.BLUE )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

}#
