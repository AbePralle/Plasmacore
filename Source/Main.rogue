uses Plasmacore

Display( "Main" ).screen = MainScreen

class Plot : Sprite
  METHODS
    method init_object

    method on( e:PointerEvent )

    method on_drag
endClass

class MainScreen : Screen [singleton]
  PROPERTIES
    scene = Scene()
    holder : Entity

  METHODS
    method on_start
      scene.add( Layer("ground") )

      local bg = Background( "background_reference.png" ).[ attach(scene), name="bg" ]

      #scene.add( Layer("over") )
      #scene.default_layer = "under"

      local entities = Entity[]
      local start_x = 614
      local start_y = 759
      forEach (j in 0..2)
        local x = start_x
        local y = start_y
        forEach (i in 0..2)
          entities.add( Plot("plot_blocked.png").[ name="plot"+(j*3+i), position=XY(x,y) ] )
          x -= 134
          y -= 72
        endForEach
        start_x += 134
        start_y -= 72
      endForEach
      entities.reverse
      bg.add( forEach in entities )

      scene.add( Layer("crops"), &make_default )

      entities.clear
      local carrots = Entity( bg//plot0.size ).[ name="carrots" ]
      bg//plot0.add( carrots, &center )
      local top    = XY( 109,   25.5 )
      local left   = XY( 46.5,  56.5 )
      local right  = XY( 171.5, 56.5 )
      local bottom = XY( 109,   88.5 )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ name="carrot", position=top ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=(top+left)/2 ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=(top+right)/2 ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=left ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=(top+bottom)/2 ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=right ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=(left+bottom)/2 ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=(right+bottom)/2 ] )
      entities.add( Sprite("carrot.png").[anchor=Anchor.BOTTOM].[ position=bottom ] )
      forEach (entity at i in entities) entity.order = i
      entities.reverse
      carrots.add( forEach in entities )

      scene._update_transforms
      change_state( IdleState() )

    method on( e:KeyEvent )
      if (e.is_press(Keycode.LEFT_ARROW))  shift_plots( XY(-1,0) )
      if (e.is_press(Keycode.RIGHT_ARROW)) shift_plots( XY(1,0) )
      if (e.is_press(Keycode.UP_ARROW))    shift_plots( XY(0,-1) )
      if (e.is_press(Keycode.DOWN_ARROW))  shift_plots( XY(0,1) )
      if (e.is_press(Keycode.V))
        local setting = not scene.child.child.is_enabled
        scene.child.apply_to_children( (entity) with (setting) => entity.enabled = setting )
      endIf

    method shift_plots( delta:XY )
      scene.child.apply_to_children( (entity) with (delta) => entity.position += delta )

    method on_draw
      Display.clear( Color.BLUE )
      scene.draw
      #SystemFont.anchor = Anchor.TOP_RIGHT
      #SystemFont.draw( scene//carrot.position->String, Display.at(1,0) )

      #scene.apply( (entity)=>entity.bounding_quad.draw(Color.RED) )
      #scene.apply( (entity)=>entity.bounding_box.draw(Color.RED) )
      #scene.child.child.bounding_box.draw( Color.RED )
      #holder.bounding_box.draw( Color.RED )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

class MainState : State<<MainScreen>>;

class IdleState : MainState
  METHODS
    method on( e:PointerEvent )
      screen.scene.handle( e )
      #{
      if (e.is_press)
        local entity = screen.scene.find( e.position, &selectable )
        if (entity) change_state( DragState(entity,e.position) )
      endIf
      }#
endClass

class DragState : MainState
  PROPERTIES
    entity : Entity
    offset : XY

  METHODS
    method init( entity, position:XY )
      offset = entity.position - entity.to_parent_local(position)

    method on( e:PointerEvent )
      if (e.is_move)
        entity.position = entity.to_parent_local(e.position) + offset
      elseIf (e.is_release)
        change_state( IdleState() )
      endIf
endClass

#{
class MainScreen : Screen [singleton]
  PROPERTIES

  METHODS
    method on_start
      change_state( InitialState() )

    method on( e:PointerEvent )

    method on_draw

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass


class InitialState : State<<MainScreen>>
  METHODS
    method on_start
      # Called when this state becomes the active state
      println "Hello World"

    method after_draw
      # This happens after the current screen's on_draw()

    method on( e:KeyEvent )
      trace e

    method on( e:PointerEvent )
      if (e.is_press or e.is_release) trace e

    method on( e:TextEvent )
      trace e

    method on_draw
      # This happens before the current screen's on_draw()
      Display.clear( Color.BLUE )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

}#
