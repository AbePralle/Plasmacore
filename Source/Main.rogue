uses Plasmacore

Display( "Main" ).screen = MainScreen

class Plot : Actor
  METHODS
    method on( e:PointerEvent )

    method on_drag
endClass

class Carrot : Actor
  METHODS
    method init( position )
      prior.init( "carrot.png" )
      anchor = Anchor.BOTTOM
endClass

class GameTextField : TextField
  METHODS
    method on_draw( layer:Layer )
      local old_color = font.color
      font.color = Color.BLACK
      layer.draw( font, text, position+XY(2,2) )
      font.color = old_color
      prior.on_draw( layer )
endClass

class MainScreen : Screen [singleton]
  PROPERTIES
    scene = Scene()
    editor = SceneEditor( scene )
    holder : Entity

  METHODS
    method on_start
      scene.add( Layer("ground") )

      local bg = Background( "background_reference.png" ).[ attach(scene), name="bg" ]

      #scene.add( Layer("over") )
      #scene.default_layer = "under"

      local entities = Entity[]
      local start_x = 614
      local start_y = 759
      forEach (j in 0..2)
        local x = start_x
        local y = start_y
        forEach (i in 0..2)
          entities.add( Plot("plot_blocked.png").[ name="plot"+(j*3+i), position=XY(x,y) ] )
          x -= 134
          y -= 72
        endForEach
        start_x += 134
        start_y -= 72
      endForEach
      entities.reverse
      bg.add( forEach in entities )

      TextField.default_font = Font( "Font-GameFont-36.png" ).[ height=34 ]

      bg//plot5.add( GameTextField("3.1B"), XY(108,71) )
      bg//plot5.add( Actor("coin.png"), XY(109,41) )

      scene.add( Layer("crops"), &make_default )

      local carrots = Entity( bg//plot0.size ).[ name="carrots" ]
      bg//plot0.add( carrots, &center )
      local top    = XY( 109,   25.5 )
      local left   = XY( 46.5,  56.5 )
      local right  = XY( 171.5, 56.5 )
      local bottom = XY( 109,   88.5 )
      carrots.add( Carrot( top ).[ order=1 ] )
      carrots.add( Carrot( (top+left)/2 ).[ order=2 ] )
      carrots.add( Carrot( (top+right)/2 ).[ order=3 ] )
      carrots.add( Carrot( left ).[ order=4 ] )
      carrots.add( Carrot( (top+bottom)/2 ).[ order=5 ] )
      carrots.add( Carrot( right ).[ order=6 ] )
      carrots.add( Carrot( (left+bottom)/2 ).[ order=7 ] )
      carrots.add( Carrot( (right+bottom)/2 ).[ order=8 ] )
      carrots.add( Carrot( bottom ).[ order=9 ] )

      change_state( IdleState() )

    method on( e:KeyEvent )
      editor.handle( e )

    method on_draw
      Display.clear( Color.BLUE )
      editor.draw
      #SystemFont.anchor = Anchor.TOP_RIGHT
      #SystemFont.draw( scene//carrot.position->String, Display.at(1,0) )

      #scene.apply( (entity)=>entity.bounding_quad.draw(Color.RED) )
      #scene.apply( (entity)=>entity.bounding_box.draw(Color.RED) )
      #scene.child.child.bounding_box.draw( Color.RED )
      #holder.bounding_box.draw( Color.RED )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

class MainState : State<<MainScreen>>;

class IdleState : MainState
  METHODS
    method on( e:PointerEvent )
      screen.editor.handle( e )
      #{
      if (e.is_press)
        local entity = screen.scene.find( e.position, &selectable )
        if (entity) change_state( DragState(entity,e.position) )
      endIf
      }#
endClass

class DragState : MainState
  PROPERTIES
    entity : Entity
    offset : XY

  METHODS
    method init( entity, position:XY )
      offset = entity.position - entity.to_parent_local(position)

    method on( e:PointerEvent )
      if (e.is_move)
        entity.position = entity.to_parent_local(e.position) + offset
      elseIf (e.is_release)
        change_state( IdleState() )
      endIf
endClass

#{
class MainScreen : Screen [singleton]
  PROPERTIES

  METHODS
    method on_start
      change_state( InitialState() )

    method on( e:PointerEvent )

    method on_draw

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass


class InitialState : State<<MainScreen>>
  METHODS
    method on_start
      # Called when this state becomes the active state
      println "Hello World"

    method after_draw
      # This happens after the current screen's on_draw()

    method on( e:KeyEvent )
      trace e

    method on( e:PointerEvent )
      if (e.is_press or e.is_release) trace e

    method on( e:TextEvent )
      trace e

    method on_draw
      # This happens before the current screen's on_draw()
      Display.clear( Color.BLUE )

    method on_resize
      # Called when the Display.size changes

    method on_update
      # Called 60 times a second
endClass

}#
