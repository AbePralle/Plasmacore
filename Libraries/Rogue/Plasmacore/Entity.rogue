module Plasmacore

class Entity
  DEFINITIONS
    ENABLED         = 1
    PRESSABLE       = 2
    SELECTABLE      = 4
    DRAGGABLE       = 8

    DRAG_THRESHOLD  = 4

  GLOBAL PROPERTIES
    selected            : Entity
    press_position      : XY
    original_position   : XY
    drag_offset         : XY
    is_dragging         : Logical
    any_bounds_modified : Logical

  PROPERTIES
    parent          : Entity
    child           : Entity
    sibling         : Entity
    name            = ""
    position        : XY
    size            : XY
    scale           = XY(1,1)
    anchor          = Anchor.CENTER : Anchor
    rotation        : Angles
    z               = 0.0
    opacity         = 1.0
    order           = 0
    attributes      = Entity.ENABLED : Int32
    layer_mask      : Int32
    _transform      : Matrix

  METHODS
    method init

    method init( size )

    method init( bounds:Box )
      position = bounds.center
      size = bounds.size

    method init_object
      if (this not instanceOf Scene)
        if (Scene.current and (Scene.current.default_layer or Scene.current.@layers.count <= 1))
          if (Scene.current.@layers.is_empty) Scene.current.add( Layer("default") )

          if (Scene.current.default_layer)   layer_mask = Scene.current.default_layer.mask
          else                               layer_mask = Scene.current.@layers.first.mask
        endIf
      endIf

    method add( entity:Entity, at_position=null:XY?, &translate, &center )
      if (entity.parent is this) return

      if (at_position.exists) entity.position = at_position.value
      elseIf (center)         entity.position = size/2

      if (translate) entity.position = entity.to_parent_screen( entity.position )

      entity.detach
      entity.parent = this
      if (child)
        local cur = child
        while (cur.sibling) cur = cur.sibling
        cur.sibling = entity
      else
        child = entity
      endIf

      if (translate) entity.position = entity.to_parent_local( entity.position )

    method apply( fn:Function(Entity) )
      fn( this )
      apply_to_children( fn )

    method apply_to_children( fn:Function(Entity) )
      local cur = child
      while (cur)
        cur.apply( fn )
        cur = cur.sibling
      endWhile

    method attach( parent:Entity, &translate )
      parent.add( this, &=translate )

    method bounding_box->Box
      if (size.is_zero)
        return Box(0,0,0,0)
      else
        return Box( position, size ).relative_to( anchor ).transform( transform )->Box
      endIf

    method bounding_quad->Quad
      if (size.is_zero)
        return Box(0,0,0,0)->Quad
      else
        return Box( position, size ).relative_to( anchor ).transform( transform )
      endIf

    method child->Entity
      return @child

    method collect_active_entities( entities:Entity[] )
      if (not is_enabled) return
      entities.add( this )

      local cur = child
      while (cur)
        cur.collect_active_entities( entities )
        cur = cur.sibling
      endWhile

    method contains( xy:XY )->Logical
      return bounding_quad.contains(xy)

    method detach
      if (not parent) return

      if (parent.child is this)
        parent.child = this.sibling
      else
        local cur = parent.child
        while (cur.sibling)
          if (cur.sibling is this)
            cur.sibling = this.sibling
            escapeWhile
          endIf
          cur = cur.sibling
        endWhile
      endIf

      parent = null
      sibling = null

    method draggable
      attributes |= DRAGGABLE
      if (not (attributes & (PRESSABLE | SELECTABLE))) attributes |= SELECTABLE

    method get( entity_name:String )->Entity
      if (name == entity_name) return this

      local cur = child
      while (cur)
        local result = cur[ entity_name ]
        if (result) return result
        cur = cur.sibling
      endWhile

      return null

    method handle( e:PointerEvent, mask:Int32 )
      if (sibling)
        sibling.handle( e, mask )
        if (e.is_consumed) return
      endIf

      if (child)
        child.handle( e, mask )
        if (e.is_consumed) return
      endIf

      if (not (mask & layer_mask))
        return
      endIf

      if (not bounding_quad.contains(e.position)) return

      on( e )
      if (e.is_consumed) return

      if (Entity.selected is null and e.is_press)
        if (this.is_pressable or this.is_selectable)
          Entity.selected = this
          Entity.press_position = e.position
          Entity.original_position = this.position
          Entity.drag_offset = position - this.to_parent_local(e.position)
          if (this.is_pressable)
            # 'pressable' starts dragging right away; 'selectable' waits until threshold exceeded
            Entity.is_dragging = true
            Entity.selected.position = Entity.selected.to_parent_local( e.position ) + Entity.drag_offset
            on_drag
          else
            Entity.is_dragging = false
          endIf
          e.consume
        endIf
      endIf

    method layers->LayerMask
      return LayerMask(layer_mask)

    method is_enabled->Logical [macro]
      return (this.attributes & Entity.ENABLED)

    method is_draggable->Logical [macro]
      return (this.attributes & Entity.DRAGGABLE)

    method is_pressable->Logical [macro]
      return (this.attributes & Entity.PRESSABLE)

    method is_selectable->Logical [macro]
      return (this.attributes & Entity.SELECTABLE)

    method name->String
      if (@name is null or @name.count == 0) name = type_name.after_any("::")
      return @name

    method on( e:PointerEvent )

    method on_drag

    method on_draw( layer:Layer )

    method pressable
      attributes |= PRESSABLE


    method find( xy:XY, &selectable_only )->Entity
      if (not is_enabled) return null

      local best : Entity

      if (child)
        local cur = child
        while (cur)
          local result = cur.find( xy, &=selectable_only )
          if (result and (not best or best.order < result.order)) best = result
          cur = cur.sibling
        endWhile
      endIf

      if (best and best.order >= this.order)     return best
      if (selectable_only and not is_selectable) return best
      if (not this.contains(xy)) return best
      return this

    method replace_with( other:Entity )
      if (child) other.add( child ); child = null

      local cur = other
      while (cur.sibling) cur = cur.sibling
      cur.sibling = sibling
      sibling = null

      if (parent)
        if (parent.child is this)
          parent.child = other
        else
          cur = parent.child
          while (cur.sibling and cur.sibling is not this) cur = cur.sibling
          cur.sibling = this
        endIf
        parent = null
      endIf

    method selectable
      attributes |= SELECTABLE

    method set_enabled( setting:Logical )
      if (setting) attributes |=  Entity.ENABLED
      else         attributes &= !Entity.ENABLED

    method set_anchor( new_anchor:Anchor )
      if (new_anchor != anchor)
        @anchor = new_anchor
        any_bounds_modified = true
      endIf

    method set_layers( new_layer:Layer )
      layer_mask = new_layer.mask

    method set_layers( mask:LayerMask )
      layer_mask = mask.value

    method set_layers( layer_name:String )
      if (Scene.current)
        local layer = Scene.current.layer( layer_name )
        if (layer) layer_mask = layer.mask
      endIf

    method set_position( new_position:XY )
      if (new_position != position)
        @position = new_position
        any_bounds_modified = true
      endIf

    method set_rotation( new_rotation:Angles )
      if (new_rotation != rotation)
        @rotation = new_rotation
        any_bounds_modified = true
      endIf

    method set_rotation( new_angle:Radians )
      set_rotation( new_angle->Degrees )

    method set_rotation( new_angle:Degrees )
      if (new_angle != rotation.z)
        @rotation = Angles( rotation.x, rotation.y, new_angle )
        any_bounds_modified = true
      endIf

    method set_scale( new_scale:Real64 )
      set_scale( XY(new_scale,new_scale) )

    method set_scale( new_scale:XY )
      if (new_scale != scale)
        @scale = new_scale
        any_bounds_modified = true
      endIf

    method set_size( new_size:XY )
      if (new_size != size)
        @size = new_size
        any_bounds_modified = true
      endIf

    method set_z( new_z:Real64 )
      if (new_z != z)
        @z = new_z
        any_bounds_modified = true
      endIf

    method subtree_bounds->Box
      return subtree_bounds( Box(0,0,0,0) )

    method subtree_bounds( box:Box )->Box
      box |= bounding_box

      local cur = child
      while (cur)
        box |= cur.subtree_bounds( box )
        cur = cur.sibling
      endWhile

      return box

    method to->String
      if (name.count) return name
      return type_name

    method to_local( xy:XY )->XY
      if (parent) xy = parent.to_local( xy )
      xy = (xy - position) / scale
      if (rotation.z.value) xy = xy.rotated( -rotation.z )
      return xy + anchor.position * size

    method to_parent_local( xy:XY )->XY
      if (parent) return parent.to_local( xy )
      return xy

    method to_screen( xy:XY )->XY
      xy -= anchor.position * size
      if (rotation.z.value) xy = xy.rotated( rotation.z )
      xy *= scale
      xy += position
      if (parent) xy = parent.to_screen( xy )
      return xy

    method to_parent_screen( xy:XY )->XY
      if (parent) return parent.to_screen( xy )
      return xy

    method transform->Matrix
      if (any_bounds_modified) _update_transforms
      return @_transform

    method _update_transforms
      if (parent)
        parent._update_transforms
      else
        any_bounds_modified = false
        _update_transform
      endIf

    method _update_transform
      if (not is_enabled) return

      _transform = Display.world_transform

      local handle = XYZ( (anchor.position * scale * size), 0 )

      local has_rotation = not rotation.is_zero
      if (has_rotation)
        Display.push_view_transform( Quaternion(rotation)->Matrix( handle, XYZ(position,z)) )
      else
        Display.push_view_transform( Matrix.translate(XYZ(position,z)-handle) )
      endIf

      Display.push_view_transform( Matrix.scale(XYZ(scale,1)) )


      if (child)
        local cur = child
        while (cur)
          cur._update_transform
          cur = cur.sibling
        endWhile
      endIf

      Display.pop_view_transform( 2 )
endClass

class LayerMask( value:Int32 ) [compound]
  METHODS
    method operator+( layer:Layer )->LayerMask
      return LayerMask( value | layer.mask )

    method operator+( layer_name:String )->LayerMask
      if (Scene.current)
        local layer = Scene.current.layer( layer_name )
        if (layer) return LayerMask( value | layer.mask )
      endIf
      return this

    method operator-( layer:Layer )->LayerMask
      return LayerMask( value & !layer.mask )

    method operator-( layer_name:String )->LayerMask
      if (Scene.current)
        local layer = Scene.current.layer( layer_name )
        if (layer) return LayerMask( value & !layer.mask )
      endIf
      return this

endClass

class DragAndDrop
endClass

class Layer
  PROPERTIES
    scene : Scene
    name  : String
    mask  : Int32

  METHODS
    method init( name )

    method draw( image:Image )
      image.draw

    method draw( font:Font, text:String, position:XY )
      font.draw( text, position )

    method set_name( new_name:String )
      if (scene)
        scene.layer_lookup.remove( name )
        scene.layer_lookup[ new_name ] = this
      endIf
      @name = new_name
endClass


class Scene : Entity
  GLOBAL PROPERTIES
    current : Scene

  PROPERTIES
    is_fullscreen : Logical
    layers        = Layer[]
    layer_lookup  = StringTable<<Layer>>()
    default_layer : Layer
    entities      = Entity[]

  METHODS
    method init
      is_fullscreen = true
      current = this

    method activate
      current = this

    method add( layer:Layer, &make_default )
      require @layers.count < 32

      local layer_mask = 0
      layer_mask |= (forEach in @layers).mask
      forEach (bit_pos in 0..31)
        if (0 == (layer_mask & (1:<<:bit_pos)))
          layer.mask = (1:<<:bit_pos)
          escapeForEach
        endIf
      endForEach

      layer.scene = this
      @layers.add( layer )
      layer_lookup[ layer.name ] = layer

      if (make_default or @layers.count == 1) @default_layer = layer

    method handle( e:PointerEvent )
      if (Entity.selected)
        if (e.is_move)
          contingent
            sufficient (Entity.is_dragging)
            necessary (Entity.selected.is_draggable)
            necessary ((e.position - press_position).has_magnitude_greater_than(DRAG_THRESHOLD))
          satisfied
            Entity.is_dragging = true
            Entity.selected.position = Entity.selected.to_parent_local( e.position ) + Entity.drag_offset
            Entity.selected.on_drag
            return
          endContingent
        elseIf (e.is_release)
          Entity.selected = null
          return
        endIf
      endIf

      forEach (layer in @layers step -1)
        handle( e, layer.mask )
        if (e.is_consumed) return
      endForEach

    method draw
      if (@layers.is_empty) return

      if (is_fullscreen)
        size = Display.size
        position = Display.center
      endIf

      entities.clear
      collect_active_entities( entities )
      entities.sort( (a,b)=>a.order <= b.order )
      forEach (layer in @layers)
        forEach (entity in entities)
          if (entity.layer_mask & layer.mask)
            if (entity.opacity)
              Display.push_view_transform( entity.transform, &override )
              entity.on_draw( layer )
              Display.pop_view_transform
            endIf
          endIf
        endForEach
      endForEach


    method layer( name:String )->Layer
      return layer_lookup[ name ]

    method set_default_layer( @default_layer )

    method set_default_layer( layer_name:String )
      @default_layer = layer( layer_name )

endClass


class Actor : Entity
  PROPERTIES
    image : Image

  METHODS
    method init( image )
      size = image.size

    method init( image_name:String )
      init( Image(image_name) )

    method image->Image
      return @image

    method on( e:PointerEvent )

    method on_draw( layer:Layer )
      local img = image
      prepare_image( img )
      layer.draw( img )

    method prepare_image( img:Image )
      img.position = position
      img.z = z
      img.rotation = rotation
      img.size = size
      img.scale = scale
      img.anchor = anchor
      img.opacity = opacity

endClass


class Background : Actor
  ENUMERATE
    FIT
    FILL

  PROPERTIES
    style : Int32
    essential_content = XY(1.0,1.0)

  METHODS
    method init( image, essential_content=XY(1,1), style=Background.FILL )
      prior.init( image )
      size = image.original_size
      compute_bounds

    method init( image_name:String, essential_content=XY(1,1), style=Background.FILL )
      init( Image(image_name), essential_content, style )

    method compute_bounds
      which (style)
        case FIT
          local parent_size = select{ parent:parent.size || Display.size }
          position = parent_size / 2
          scale = (parent_size / size).min

        case FILL
          local parent_size = select{ parent:parent.size || Display.size }
          position = parent_size / 2
          local essential_scale = (parent_size / (size*essential_content)).min
          local whole_scale = (parent_size / size).max
          scale = essential_scale.or_larger( whole_scale )
      endWhich

      anchor = Anchor.CENTER

    method prepare_image( img:Image )
      compute_bounds
      prior.prepare_image( img )
endClass

class TextField : Entity
  GLOBAL PROPERTIES
    default_font : Font

  PROPERTIES
    font : Font
    text : String

  METHODS
    method init( text:String )
      init( text, default_font )

    method init( text, font )
      size = font.measure( text )

    method on_draw( layer:Layer )
      layer.draw( font, text, position )

endClass


class SceneEditor : Scene
  PROPERTIES
    scene         : Scene
    active_entity : Entity

  METHODS
    method init( scene )

    method draw
      scene.draw
      prior.draw
      if (active_entity)
        local bounds = active_entity.bounding_quad
        bounds.draw( Color.RED )
        SystemFont.anchor = Anchor.TOP
        SystemFont.draw( active_entity.position->String, bounds->Box.at(0.5,1) )
      endIf

    method handle( e:KeyEvent )
      if (e.is_press(Keycode.LEFT_ARROW) and active_entity)  active_entity.position += XY(-1,0)
      if (e.is_press(Keycode.RIGHT_ARROW) and active_entity) active_entity.position += XY(1,0)
      if (e.is_press(Keycode.UP_ARROW) and active_entity)    active_entity.position += XY(0,-1)
      if (e.is_press(Keycode.DOWN_ARROW) and active_entity)  active_entity.position += XY(0,1)
      if (e.is_press(Keycode.V) and active_entity)           active_entity.enabled = not active_entity.is_enabled

    method handle( e:PointerEvent )
      if (e.is_press)
        active_entity = scene.find( e.position )
      endIf

endClass
