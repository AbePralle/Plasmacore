module Plasmacore

class Scene : Entity
  PROPERTIES
    is_fullscreen = true
    types         = StringTable<<EntityType>>()
    type_list     = EntityType[]
    draw_list     = Entity[]
    ids           = StringLookupList()

  METHODS
    method init
      noAction

    method draw
      draw( ids.id("draw_default") )

    method draw( m_draw_id:Int32 )
      draw_list.clear
      if (children)
        (forEach in children).call( m_draw_id )
      endIf
      forEach (entity in draw_list)
        entity.on_draw
      endForEach

    method type( name:String )->EntityType
      local type = types[ name ]
      if (type) return type

      ensure type( this, name, type_list.count )
      types[ name ] = type
      type_list.add( type )
      return type
endClass

class EntityType
  PROPERTIES
    scene  : Scene
    name   : String
    index  : Int32
    images = Image[]
    sounds = Sound[]

  METHODS
    method init( scene, name, index )

    method call( context:Entity, m_id:Int32 )
      println "$.$()" (name,m_id)
      scene.draw_list.add( context )
      if (context.children)
        forEach (child in context.children)
          child.call( m_id )
        endForEach
      endIf

    method spawn( parent:Entity, intial_position=XY(0,0):XY )->Entity
      return parent.add( Entity(this).[ position=intial_position ] )

    method to->String
      return name
endClass

class Entity
  DEFINITIONS
    DISABLED        = 1
    PRESSABLE       = 2
    SELECTABLE      = 4
    DRAGGABLE       = 8

    DRAG_THRESHOLD  = 4

  GLOBAL PROPERTIES
    selected            : Entity
    press_position      : XY
    original_position   : XY
    drag_offset         : XY
    is_dragging         : Logical
    any_bounds_modified : Logical

  PROPERTIES
    type       : EntityType
    parent     : Entity
    children   : Entity[]
    image      : Image
    name       = ""
    position   : XY
    size       : XY
    scale      = XY(1,1)
    anchor     = Anchor.CENTER : Anchor
    rotation   : Angles
    z          = 0.0
    opacity    = 1.0
    attributes : Int32
    state      : Int32
    frame      : Int32
    transform  : Matrix

  METHODS
    method init( type )

      #{
    method init( size )

    method init( bounds:Box )
      position = bounds.center
      size = bounds.size
      }#

    method add( entity:Entity )->Entity
      if (entity.parent is this) return entity

      if (entity.parent) entity.parent.remove( entity )
      entity.parent = this

      ensure children(2)
      children.add( entity )

      return entity

      #{
    method apply( fn:Function(Entity) )
      fn( this )
      apply_to_children( fn )

    method apply_to_children( fn:Function(Entity) )
      local cur = child
      while (cur)
        cur.apply( fn )
        cur = cur.sibling
      endWhile

    method attach( parent:Entity, &translate )
      parent.add( this, &=translate )

    method bounding_box->Box
      if (size.is_zero)
        return Box(0,0,0,0)
      else
        return Box( position, size ).relative_to( anchor ).transform( transform )->Box
      endIf

    method bounding_quad->Quad
      if (size.is_zero)
        return Box(0,0,0,0)->Quad
      else
        return Box( position, size ).relative_to( anchor ).transform( transform )
      endIf
      }#

    method call( method_name:String )
      call( type.scene.ids.id(method_name) )

    method call( m_id:Int32 )
      type.call( this, m_id )

      #{
    method child->Entity
      return @child

    method collect_active_entities( entities:Entity[] )
      if (is_disabled) return
      entities.add( this )

      local cur = child
      while (cur)
        cur.collect_active_entities( entities )
        cur = cur.sibling
      endWhile

    method contains( xy:XY )->Logical
      return bounding_quad.contains(xy)

    method detach
      if (not parent) return

      if (parent.child is this)
        parent.child = this.sibling
      else
        local cur = parent.child
        while (cur.sibling)
          if (cur.sibling is this)
            cur.sibling = this.sibling
            escapeWhile
          endIf
          cur = cur.sibling
        endWhile
      endIf

      parent = null
      sibling = null

    method draggable
      attributes |= DRAGGABLE
      if (not (attributes & (PRESSABLE | SELECTABLE))) attributes |= SELECTABLE
      }#

    method draw
      type.scene.draw_list.add( this )
      if (children)
        (forEach in children).draw
      endIf

      #{
    method get( entity_name:String )->Entity
      if (name == entity_name) return this

      local cur = child
      while (cur)
        local result = cur[ entity_name ]
        if (result) return result
        cur = cur.sibling
      endWhile

      return null

    method handle( e:PointerEvent, mask:Int32 )
      if (sibling)
        sibling.handle( e, mask )
        if (e.is_consumed) return
      endIf

      if (child)
        child.handle( e, mask )
        if (e.is_consumed) return
      endIf

      if (not (mask & layer_mask))
        return
      endIf

      if (not bounding_quad.contains(e.position)) return

      on( e )
      if (e.is_consumed) return

      if (Entity.selected is null and e.is_press)
        if (this.is_pressable or this.is_selectable)
          Entity.selected = this
          Entity.press_position = e.position
          Entity.original_position = this.position
          Entity.drag_offset = position - this.to_parent_local(e.position)
          if (this.is_pressable)
            # 'pressable' starts dragging right away; 'selectable' waits until threshold exceeded
            Entity.is_dragging = true
            Entity.selected.position = Entity.selected.to_parent_local( e.position ) + Entity.drag_offset
            on_drag
          else
            Entity.is_dragging = false
          endIf
          e.consume
        endIf
      endIf

    method layers->LayerMask
      return LayerMask(layer_mask)

    method is_disabled->Logical [macro]
      return (this.attributes & Entity.DISABLED)

    method is_draggable->Logical [macro]
      return (this.attributes & Entity.DRAGGABLE)

    method is_pressable->Logical [macro]
      return (this.attributes & Entity.PRESSABLE)

    method is_selectable->Logical [macro]
      return (this.attributes & Entity.SELECTABLE)

    method name->String
      if (@name is null or @name.count == 0) name = type_name.after_any("::")
      return @name

    method on( e:PointerEvent )

    method on_drag
      }#

    method on_draw
      if (image)
        image.draw
      endIf

      #{
    method pressable
      attributes |= PRESSABLE


    method find( xy:XY, &selectable_only )->Entity
      if (is_disabled) return null

      local best : Entity

      if (child)
        local cur = child
        while (cur)
          local result = cur.find( xy, &=selectable_only )
          if (result and (not best or best.order < result.order)) best = result
          cur = cur.sibling
        endWhile
      endIf

      if (best and best.order >= this.order)     return best
      if (selectable_only and not is_selectable) return best
      if (not this.contains(xy)) return best
      return this

    method replace_with( other:Entity )
      if (child) other.add( child ); child = null

      local cur = other
      while (cur.sibling) cur = cur.sibling
      cur.sibling = sibling
      sibling = null

      if (parent)
        if (parent.child is this)
          parent.child = other
        else
          cur = parent.child
          while (cur.sibling and cur.sibling is not this) cur = cur.sibling
          cur.sibling = this
        endIf
        parent = null
      endIf
      }#

    method remove( entity:Entity )->Entity
      children.remove( entity )
      return entity

      #{
    method selectable
      attributes |= SELECTABLE

    method set_disabled( setting:Logical )
      if (setting) attributes |=  Entity.DISABLED
      else         attributes &= !Entity.DISABLED

    method set_anchor( new_anchor:Anchor )
      if (new_anchor != anchor)
        @anchor = new_anchor
        any_bounds_modified = true
      endIf

    method set_layers( new_layer:Layer )
      layer_mask = new_layer.mask

    method set_layers( mask:LayerMask )
      layer_mask = mask.value

    method set_layers( layer_name:String )
      if (Scene.current)
        local layer = Scene.current.layer( layer_name )
        if (layer) layer_mask = layer.mask
      endIf

    method set_position( new_position:XY )
      if (new_position != position)
        @position = new_position
        any_bounds_modified = true
      endIf

    method set_rotation( new_rotation:Angles )
      if (new_rotation != rotation)
        @rotation = new_rotation
        any_bounds_modified = true
      endIf

    method set_rotation( new_angle:Radians )
      set_rotation( new_angle->Degrees )

    method set_rotation( new_angle:Degrees )
      if (new_angle != rotation.z)
        @rotation = Angles( rotation.x, rotation.y, new_angle )
        any_bounds_modified = true
      endIf

    method set_scale( new_scale:Real64 )
      set_scale( XY(new_scale,new_scale) )

    method set_scale( new_scale:XY )
      if (new_scale != scale)
        @scale = new_scale
        any_bounds_modified = true
      endIf

    method set_size( new_size:XY )
      if (new_size != size)
        @size = new_size
        any_bounds_modified = true
      endIf

    method set_z( new_z:Real64 )
      if (new_z != z)
        @z = new_z
        any_bounds_modified = true
      endIf

    method subtree_bounds->Box
      return subtree_bounds( Box(0,0,0,0) )

    method subtree_bounds( box:Box )->Box
      box |= bounding_box

      local cur = child
      while (cur)
        box |= cur.subtree_bounds( box )
        cur = cur.sibling
      endWhile

      return box
      }#

    method to->String
      return "$:$" (name,type.name)

      #{
    method to_local( xy:XY )->XY
      if (parent) xy = parent.to_local( xy )
      xy = (xy - position) / scale
      if (rotation.z.value) xy = xy.rotated( -rotation.z )
      return xy + anchor.position * size

    method to_parent_local( xy:XY )->XY
      if (parent) return parent.to_local( xy )
      return xy

    method to_screen( xy:XY )->XY
      xy -= anchor.position * size
      if (rotation.z.value) xy = xy.rotated( rotation.z )
      xy *= scale
      xy += position
      if (parent) xy = parent.to_screen( xy )
      return xy

    method to_parent_screen( xy:XY )->XY
      if (parent) return parent.to_screen( xy )
      return xy

    method transform->Matrix
      if (any_bounds_modified) _update_transforms
      return @_transform

    method _update_transforms
      if (parent)
        parent._update_transforms
      else
        any_bounds_modified = false
        _update_transform
      endIf

    method _update_transform
      if (is_disabled) return

      _transform = Display.world_transform

      local handle = XYZ( (anchor.position * scale * size), 0 )

      local has_rotation = not rotation.is_zero
      if (has_rotation)
        Display.push_view_transform( Quaternion(rotation)->Matrix( handle, XYZ(position,z)) )
      else
        Display.push_view_transform( Matrix.translate(XYZ(position,z)-handle) )
      endIf

      Display.push_view_transform( Matrix.scale(XYZ(scale,1)) )


      if (child)
        local cur = child
        while (cur)
          cur._update_transform
          cur = cur.sibling
        endWhile
      endIf

      Display.pop_view_transform( 2 )
}#
endClass


#{
class Scene
  PROPERTIES
    is_fullscreen : Logical
    entities      = Entity[]

  METHODS
    method init
      is_fullscreen = true

    method handle( e:PointerEvent )
      #{
      if (Entity.selected)
        if (e.is_move)
          contingent
            sufficient (Entity.is_dragging)
            necessary (Entity.selected.is_draggable)
            necessary ((e.position - press_position).has_magnitude_greater_than(DRAG_THRESHOLD))
          satisfied
            Entity.is_dragging = true
            Entity.selected.position = Entity.selected.to_parent_local( e.position ) + Entity.drag_offset
            Entity.selected.on_drag
            return
          endContingent
        elseIf (e.is_release)
          Entity.selected = null
          return
        endIf
      endIf

      forEach (layer in @layers step -1)
        handle( e, layer.mask )
        if (e.is_consumed) return
      endForEach
      }#

    method draw
      #{
      if (@layers.is_empty) return

      if (is_fullscreen)
        size = Display.size
        position = Display.center
      endIf

      make_current
      entities.clear
      collect_active_entities( entities )
      entities.sort( (a,b)=>a.order <= b.order )
      forEach (layer in @layers)
        forEach (entity in entities)
          if (entity.layer_mask & layer.mask)
            if (entity.opacity)
              Display.push_view_transform( entity.transform, &override )
              entity.on_draw( layer )
              Display.pop_view_transform
            endIf
          endIf
        endForEach
      endForEach
      }#

endClass
}#


#{
class Actor : Entity
    method prepare_image( img:Image )
      img.position = position
      img.z = z
      img.rotation = rotation
      img.size = size
      img.scale = scale
      img.anchor = anchor
      img.opacity = opacity
endClass
}#


#{
class Background : Actor
  ENUMERATE
    FIT
    FILL

  PROPERTIES
    style : Int32
    essential_content = XY(1.0,1.0)

  METHODS
    method init( image, essential_content=XY(1,1), style=Background.FILL )
      prior.init( image )
      size = image.original_size
      compute_bounds

    method init( image_name:String, essential_content=XY(1,1), style=Background.FILL )
      init( Image(image_name), essential_content, style )

    method compute_bounds
      which (style)
        case FIT
          local parent_size = select{ parent:parent.size || Display.size }
          position = parent_size / 2
          scale = (parent_size / size).min

        case FILL
          local parent_size = select{ parent:parent.size || Display.size }
          position = parent_size / 2
          local essential_scale = (parent_size / (size*essential_content)).min
          local whole_scale = (parent_size / size).max
          scale = essential_scale.or_larger( whole_scale )
      endWhich

      anchor = Anchor.CENTER

    method prepare_image( img:Image )
      compute_bounds
      prior.prepare_image( img )
endClass

class TextField : Entity
  GLOBAL PROPERTIES
    default_font : Font

  PROPERTIES
    font : Font
    text : String

  METHODS
    method init( text:String )
      init( text, default_font )

    method init( text, font )
      size = font.measure( text )

    method on_draw( layer:Layer )
      layer.draw( font, text, position )

endClass


class SceneEditor : Scene
  PROPERTIES
    scene         : Scene
    active_entity : Entity

  METHODS
    method init( scene )
      is_fullscreen = true

    method draw
      scene.draw
      prior.draw
      if (active_entity)
        local bounds = active_entity.bounding_quad
        bounds.draw( Color.RED )
        SystemFont.anchor = Anchor.TOP
        SystemFont.draw( active_entity.position->String, bounds->Box.at(0.5,1) )
      endIf

    method handle( e:KeyEvent )
      if (e.is_press(Keycode.LEFT_ARROW) and active_entity)  active_entity.position += XY(-1,0)
      if (e.is_press(Keycode.RIGHT_ARROW) and active_entity) active_entity.position += XY(1,0)
      if (e.is_press(Keycode.UP_ARROW) and active_entity)    active_entity.position += XY(0,-1)
      if (e.is_press(Keycode.DOWN_ARROW) and active_entity)  active_entity.position += XY(0,1)
      if (e.is_press(Keycode.V) and active_entity)           active_entity.disabled = not active_entity.is_disabled

    method handle( e:PointerEvent )
      if (e.is_press)
        active_entity = scene.find( e.position )
      endIf

endClass
}#
